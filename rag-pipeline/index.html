<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Build a $0 RAG Engine - Interactive Tutorial</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  
 <link rel="stylesheet" href="style.css" />
</head>
<body>
  <!-- Hero Header -->
  <div class="hero">
    <div class="hero-badge">üöÄ Interactive Tutorial</div>
    <h1>Build a Serverless RAG Engine for $0</h1>
    <p class="hero-subtitle">Master modern AI architecture with Node.js, Gemini 1.5, and Cloudflare R2</p>
  </div>

  <!-- Main Container -->
  <div class="container">
    <!-- Main Content -->
    <main class="content">
      <section id="intro">
        <div>
            <span style="background-color: purple; color: white; padding: 2px 5px; border-radius: 5px;">Docs</span> Check the Full documentation of the Nodejs-Enterprise-Launchpad-v2 Template
            <p class="mb-4">Checkout <a href="https://aymenkani.github.io/docs.nodejs-starter-template-ai-v2/" target="_blank" class="text-blue-400 hover:underline">Nodejs-Enterprise-Launchpad-v2 Documentation</a></p>
        </div>
        <span class="step-header">üìñ Introduction</span>
        <h2>The Problem with "Toy" RAG Applications</h2>
        <p>You've probably seen dozens of RAG tutorials online. Most of them work great in demos but fail spectacularly in production. Why? Because they skip the hard parts:</p>
        
        <ul>
          <li><strong>No security model:</strong> Users can access each other's documents</li>
          <li><strong>Naive file handling:</strong> Uploading a 50MB PDF crashes your Node.js server</li>
          <li><strong>Expensive infrastructure:</strong> AWS egress fees drain $500/month for moderate usage</li>
          <li><strong>Blocking operations:</strong> Processing a single file freezes your entire API</li>
          <li><strong>No multimodal support:</strong> Images are ignored or poorly handled</li>
        </ul>

        <p>This tutorial teaches you how to build a <strong>production-grade RAG system</strong> that solves all of these problems‚Äîand runs completely free on generous cloud tiers.</p>

        <div class="info-box">
          <div class="info-box-title">What Makes This Different?</div>
          <p>This isn't a "hello world" tutorial. You'll implement:</p>
          <ul>
            <li><strong>Hybrid Search:</strong> Vector similarity + row-level security for multi-tenant isolation</li>
            <li><strong>Zero-Server Uploads:</strong> Direct-to-cloud file transfers using presigned URLs (no bandwidth waste)</li>
            <li><strong>Asynchronous Processing:</strong> BullMQ worker queues prevent blocking operations</li>
            <li><strong>Multimodal Intelligence:</strong> Gemini Vision understands images, not just text</li>
            <li><strong>Real Citations:</strong> AI responses include source documents with temporary signed URLs</li>
          </ul>
        </div>

        <h3>The Technology Choices</h3>
        <p>Every piece of this stack was chosen for a specific reason:</p>
        <ul>
          <li><strong>Cloudflare R2:</strong> S3-compatible storage with zero egress fees (saves $500-2000/month vs AWS)</li>
          <li><strong>Gemini 2.5 Flash:</strong> Free tier gives 15 requests/minute‚Äîperfect for prototypes that scale</li>
          <li><strong>PostgreSQL + pgvector:</strong> Mature, battle-tested database with native vector support (no vendor lock-in)</li>
          <li><strong>BullMQ:</strong> Redis-backed job queue that handles millions of tasks reliably</li>
        </ul>

        <div class="success-box info-box">
          <div class="info-box-title">Time Investment & Prerequisites</div>
          <p><strong>Estimated Time:</strong> 2-3 hours (including testing)</p>
          <p><strong>Prerequisites:</strong></p>
          <ul>
            <li>Intermediate JavaScript/TypeScript knowledge</li>
            <li>Basic understanding of async/await and Promises</li>
            <li>Familiarity with REST APIs (we use Express.js)</li>
            <li>Basic SQL knowledge (helpful but not required)</li>
          </ul>
        </div>
      </section>

      <section id="architecture">
        <span class="step-header">üèóÔ∏è Step 1</span>
        <h2>Understanding the Architecture</h2>
        <p>Before writing a single line of code, you need to understand how the pieces fit together. Our RAG pipeline follows a proven 4-phase architecture used by AI companies at scale.</p>

        <h3>The 4-Phase Workflow</h3>

        <div style="background: #f8fafc; border: 2px dashed #cbd5e1; border-radius: 12px; padding: 2rem; margin: 2rem 0; text-align: center; color: #64748b; font-weight: 600;">
          üìä 
          <img src="https://pub-ce2718d3322e486d97486bc7e573557d.r2.dev/rag_tutorial_images/rag-pipeline-architecture-diagram.jpg" width="100%" height="auto" />
          <br><br>
          <span style="font-size: 0.875rem; font-weight: 400;">Visualizing the complete flow: Upload ‚Üí Ingestion ‚Üí Vector Storage ‚Üí Retrieval ‚Üí Generation</span>
        </div>

        <h3>Phase 1: Direct-to-Cloud Uploads (Security First)</h3>
        <p>Traditional file uploads stream data through your Node.js server. This is a disaster waiting to happen:</p>
        <ul>
          <li>A 100MB file consumes 100MB of server memory</li>
          <li>10 concurrent uploads = 1GB memory spike (OOM crash)</li>
          <li>Bandwidth costs scale linearly with file size</li>
        </ul>
        
        <p><strong>Our solution:</strong> Use presigned URLs to enable direct browser-to-R2 uploads. Your server never touches the file data‚Äîit only generates time-limited upload permissions (expires in 5 minutes).</p>

        <div class="info-box">
          <div class="info-box-title">The Reservation Pattern</div>
          <p>We create a "reservation" in the database with status <code>PENDING</code> before issuing the presigned URL. This ensures:</p>
          <ul>
            <li>Rate limiting (2 uploads per 24h in demo mode)</li>
            <li>File type validation (only PDFs, images, text)</li>
            <li>Size enforcement (5MB limit)</li>
            <li>Automatic cleanup (abandoned uploads deleted after 24h)</li>
          </ul>
        </div>

        <h3>Phase 2: Asynchronous Ingestion (BullMQ Workers)</h3>
        <p>Once the file lands in R2, your API returns immediately. A background worker picks up the job from a Redis queue and processes it asynchronously:</p>
        <ol>
          <li><strong>Download from R2:</strong> Worker fetches the file using AWS SDK</li>
          <li><strong>Hash Calculation:</strong> SHA-256 deduplication (identical files aren't processed twice)</li>
          <li><strong>Content Extraction:</strong> PDFs ‚Üí <code>unpdf</code>, Images ‚Üí Gemini Vision, Text ‚Üí UTF-8 decode</li>
          <li><strong>Chunking:</strong> Split into ~1000 char chunks with 200 char overlap</li>
          <li><strong>Embedding:</strong> Convert each chunk to a 768-D vector using Gemini Embedding 004</li>
          <li><strong>Storage:</strong> Insert into PostgreSQL with pgvector column type</li>
        </ol>

        <p>This architecture prevents long-running operations from blocking your API. A 50MB PDF might take 30 seconds to process‚Äîbut your API responds in 50ms.</p>

        <h3>Phase 3: Hybrid Retrieval (Row-Level Security)</h3>
        <p>When a user asks a question, we perform intelligent retrieval in two steps:</p>
        
        <p><strong>Step 3a: Query Rewriting</strong></p>
        <p>If there's conversation history, Gemini rewrites the query to be standalone:</p>
        <pre><code><span class="line">// User: "Who is the CEO of Tesla?"</span>
<span class="line">// AI: "Elon Musk is the CEO of Tesla."</span>
<span class="line">// User: "What about SpaceX?"</span>
<span class="line"></span>
<span class="line">// Gemini rewrites: "Who is the CEO of SpaceX?"</span></code></pre>

        <p><strong>Step 3b: Vector Similarity + Access Control</strong></p>
        <p>We convert the query to a vector and search using cosine distance (<code>&lt;=&gt;</code> operator). The SQL query enforces row-level security:</p>

        <pre><code><span class="line">WHERE (d.userId = $currentUserId OR f.isPublic = true)</span></code></pre>

        <p>This ensures users can only search <em>their own documents</em> plus any documents marked as public. Multi-tenancy is built into the database layer‚Äîno application-level filtering required.</p>

        <h3>Phase 4: Contextual Generation (Streaming Responses)</h3>
        <p>The top 5 most relevant chunks are passed to Gemini Flash 2.5 as context. The model generates a response and streams it token-by-token to the client (Server-Sent Events):</p>

        <pre><code><span class="line">const stream = await streamText({</span>
<span class="line">  model: google('gemini-2.5-flash-lite'),</span>
<span class="line">  system: 'You are a helpful assistant. Answer based on the provided context.',</span>
<span class="line">  messages: [...conversationHistory],</span>
<span class="line">  context: retrievedChunks.map(c => c.content).join('\n\n')</span>
<span class="line">});</span></code></pre>

        <p>Each response includes <strong>smart citations</strong>‚Äîpresigned URLs to source documents that expire after 1 hour.</p>

        <h3>The Complete Technology Stack</h3>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem; margin: 2rem 0;">
          <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 1.5rem; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <div style="font-size: 2rem; margin-bottom: 0.5rem;">‚ö°</div>
            <div style="font-weight: 700; font-size: 1.125rem; margin-bottom: 0.5rem;">Backend</div>
            <div style="font-size: 0.9rem; opacity: 0.9;">Node.js + TypeScript<br>Express.js REST API<br>Prisma ORM</div>
          </div>

          <div style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; padding: 1.5rem; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <div style="font-size: 2rem; margin-bottom: 0.5rem;">ü§ñ</div>
            <div style="font-weight: 700; font-size: 1.125rem; margin-bottom: 0.5rem;">AI Models</div>
            <div style="font-size: 0.9rem; opacity: 0.9;">Gemini 2.5 Flash Lite<br>Gemini Embedding 004<br>Gemini Vision (images)</div>
          </div>

          <div style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; padding: 1.5rem; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <div style="font-size: 2rem; margin-bottom: 0.5rem;">üíæ</div>
            <div style="font-weight: 700; font-size: 1.125rem; margin-bottom: 0.5rem;">Database</div>
            <div style="font-size: 0.9rem; opacity: 0.9;">PostgreSQL 18<br>pgvector extension<br>ivfflat indexes</div>
          </div>

          <div style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); color: white; padding: 1.5rem; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <div style="font-size: 2rem; margin-bottom: 0.5rem;">‚òÅÔ∏è</div>
            <div style="font-weight: 700; font-size: 1.125rem; margin-bottom: 0.5rem;">Storage</div>
            <div style="font-size: 0.9rem; opacity: 0.9;">Cloudflare R2<br>S3-compatible API<br>Zero egress fees</div>
          </div>

          <div style="background: linear-gradient(135deg, #30cfd0 0%, #330867 100%); color: white; padding: 1.5rem; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <div style="font-size: 2rem; margin-bottom: 0.5rem;">‚öôÔ∏è</div>
            <div style="font-weight: 700; font-size: 1.125rem; margin-bottom: 0.5rem;">Queue</div>
            <div style="font-size: 0.9rem; opacity: 0.9;">BullMQ + Redis<br>Async job processing<br>Cron scheduling</div>
          </div>

          <div style="background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); color: #2d3748; padding: 1.5rem; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <div style="font-size: 2rem; margin-bottom: 0.5rem;">üîß</div>
            <div style="font-weight: 700; font-size: 1.125rem; margin-bottom: 0.5rem;">Developer Tools</div>
            <div style="font-size: 0.9rem; opacity: 0.8;">Zod validation<br>Pino logger<br>Jest testing</div>
          </div>
        </div>

        <div class="success-box info-box">
          <div class="info-box-title">Why This Stack Costs $0/Month</div>
          <p>Every component has a generous free tier:</p>
          <ul>
            <li><strong>Cloudflare R2:</strong> 10GB storage, unlimited egress (vs $90/TB on AWS)</li>
            <li><strong>Google AI Studio:</strong> 15 requests/minute, 1,500 requests/day for free</li>
            <li><strong>Render PostgreSQL:</strong> 256MB RAM, 1GB storage (free plan)</li>
            <li><strong>Upstash Redis:</strong> 10,000 commands/day (free plan)</li>
          </ul>
          <p>You can serve <strong>thousands of users</strong> before hitting any paid tier. Most indie projects never exceed these limits.</p>
        </div>

        <p><strong>Ready to build?</strong> Let's start with the foundation: setting up direct-to-cloud file uploads.</p>
      </section>

      <section id="phase1">
        <span class="step-header">‚òÅÔ∏è Step 2</span>
        <h2>Phase 1: Zero-Cost Storage with Cloudflare R2</h2>
        <p>Traditional cloud storage like AWS S3 charges egress fees when you download files. For a RAG system that constantly retrieves documents for context, this adds up to <strong>hundreds of dollars monthly</strong>. Cloudflare R2 eliminates this cost entirely with zero egress fees.</p>

        <h3>The Problem: Traditional File Uploads Kill Servers</h3>
        <p>In most tutorials, you'll see file uploads handled like this:</p>

        <pre><code><span class="line">// ‚ùå BAD: File streams through your server</span>
<span class="line">app.post('/upload', upload.single('file'), (req, res) => {</span>
<span class="line">  // req.file is loaded into server memory!</span>
<span class="line">  // 100MB file = 100MB RAM consumed</span>
<span class="line">  await saveToCloud(req.file);</span>
<span class="line">});</span></code></pre>

        <p><strong>What happens in production?</strong></p>
        <ul>
          <li>10 concurrent users uploading 50MB PDFs = <strong>500MB RAM spike</strong></li>
          <li>Your Node.js process runs out of memory (OOM) and crashes</li>
          <li>You pay egress fees twice: user ‚Üí server, then server ‚Üí cloud</li>
          <li>Bandwidth costs scale with file size and user count</li>
        </ul>

        <h3>The Solution: Reservation Pattern</h3>
        <p>Instead of streaming files through your server, we use <strong>presigned URLs</strong>‚Äîtime-limited credentials that allow the browser to upload directly to R2.</p>

        <div style="background: #f8fafc; border: 2px dashed #cbd5e1; border-radius: 12px; padding: 2rem; margin: 2rem 0; text-align: center; color: #64748b; font-weight: 600;">
          üîê
          <img src="https://pub-ce2718d3322e486d97486bc7e573557d.r2.dev/rag_tutorial_images/reservation-pattern-flow-diagram.jpg" width="100%" height="auto" />
          <br><br>
          <span style="font-size: 0.875rem; font-weight: 400;">Browser ‚Üí API (generates presigned URL) ‚Üí Browser uploads directly to R2 ‚Üí API confirms upload</span>
        </div>

        <h3>Step-by-Step Implementation</h3>

        <p><strong>1. Client Requests Upload Permission</strong></p>
        <p>The frontend calls our API to "reserve" a file slot:</p>

        <pre><code><span class="line">// Frontend: Request presigned URL</span>
<span class="line">const response = await fetch('/api/v1/upload/generate-signed-url', {</span>
<span class="line">  method: 'POST',</span>
<span class="line">  headers: {</span>
<span class="line">    'Content-Type': 'application/json',</span>
<span class="line">    'Authorization': `Bearer ${accessToken}`</span>
<span class="line">  },</span>
<span class="line">  body: JSON.stringify({</span>
<span class="line">    fileName: 'company-handbook.pdf',</span>
<span class="line">    fileType: 'application/pdf',</span>
<span class="line">    fileSize: 2097152, // 2MB</span>
<span class="line">    isPublic: false    // Private document</span>
<span class="line">  })</span>
<span class="line">});</span>
<span class="line"></span>
<span class="line">const { signedUrl, fileKey, fileId } = await response.json();</span></code></pre>

        <p><strong>2. Backend Creates Database Reservation</strong></p>
        <p>Here's the actual controller logic from <code>src/controllers/upload.controller.ts</code>:</p>

        <pre><code><span class="line">const generateSignedUrl = async (req, res, next) => {</span>
<span class="line">  try {</span>
<span class="line">    const { fileName, fileType, fileSize, isPublic } = req.body;</span>
<span class="line">    </span>
<span class="line">    // Generate presigned URL + create DB reservation (status: PENDING)</span>
<span class="line">    const { signedUrl, fileKey, fileId } = await uploadService.generateSignedUrl(</span>
<span class="line">      fileName,</span>
<span class="line">      fileType,</span>
<span class="line">      fileSize,</span>
<span class="line">      isPublic,</span>
<span class="line">      req.user // Authenticated user</span>
<span class="line">    );</span>
<span class="line">    </span>
<span class="line">    res.send({ signedUrl, fileKey, fileId });</span>
<span class="line">  } catch (error) {</span>
<span class="line">    next(error);</span>
<span class="line">  }</span>
<span class="line">};</span></code></pre>

        <div class="info-box">
          <div class="info-box-title">What Happens in uploadService?</div>
          <p>The service layer performs critical security checks before issuing the presigned URL:</p>
          <ul>
            <li><strong>Rate Limiting:</strong> In demo mode, users can upload max 2 files per 24 hours</li>
            <li><strong>File Type Validation:</strong> Only allows PDFs, images (JPEG, PNG, GIF), and text files</li>
            <li><strong>Size Enforcement:</strong> Rejects files larger than 5MB</li>
            <li><strong>Database Reservation:</strong> Creates a <code>File</code> record with status <code>PENDING</code></li>
            <li><strong>Presigned URL Generation:</strong> Creates a temporary upload URL that expires in 5 minutes</li>
          </ul>
        </div>

        <p><strong>3. Browser Uploads Directly to R2</strong></p>
        <p>The client uses the presigned URL to upload the file, <em>completely bypassing our server</em>:</p>

        <pre><code><span class="line">// Direct upload to Cloudflare R2 (or AWS S3)</span>
<span class="line">const uploadResponse = await fetch(signedUrl, {</span>
<span class="line">  method: 'PUT',</span>
<span class="line">  headers: {</span>
<span class="line">    'Content-Type': file.type</span>
<span class="line">  },</span>
<span class="line">  body: file // Raw file from input[type="file"]</span>
<span class="line">});</span>
<span class="line"></span>
<span class="line">if (!uploadResponse.ok) {</span>
<span class="line">  throw new Error('Upload to R2 failed');</span>
<span class="line">}</span></code></pre>

        <p><strong>4. Client Confirms Upload to Trigger Processing</strong></p>
        <p>After the upload succeeds, the client notifies our API to start AI processing:</p>

        <pre><code><span class="line">// Confirm upload ‚Üí triggers ingestion worker</span>
<span class="line">await fetch('/api/v1/upload/confirm', {</span>
<span class="line">  method: 'POST',</span>
<span class="line">  headers: {</span>
<span class="line">    'Content-Type': 'application/json',</span>
<span class="line">    'Authorization': `Bearer ${accessToken}`</span>
<span class="line">  },</span>
<span class="line">  body: JSON.stringify({ fileId })</span>
<span class="line">});</span></code></pre>

        <div class="success-box info-box">
          <div class="info-box-title">Why This Pattern is Production-Ready</div>
          <ul>
            <li><strong>Zero Server Memory:</strong> Files never touch your Node.js process‚Äîno OOM crashes</li>
            <li><strong>Instant Response:</strong> API returns in ~50ms, not 5 seconds waiting for upload</li>
            <li><strong>Cost Savings:</strong> R2 costs $0.015/GB vs S3's $0.09/GB + egress fees</li>
            <li><strong>Scalability:</strong> Handle 1000 concurrent uploads without increasing server resources</li>
            <li><strong>Security:</strong> Presigned URLs expire after 5 minutes‚Äîno permanent access</li>
            <li><strong>Automatic Cleanup:</strong> Abandoned files (PENDING status > 24h) are deleted automatically</li>
          </ul>
        </div>
      </section>

      <section id="phase2">
        <span class="step-header">üß† Step 3</span>
        <h2>Phase 2: The Brain - Gemini Embeddings & Smart Retrieval</h2>
        <p>Once a file is in R2, the real magic begins. Our background worker processes it asynchronously, but first, let's understand the <strong>retrieval problem</strong> that RAG systems must solve.</p>

        <h3>The Context Problem: Why "What about him?" Fails</h3>
        <p>Imagine this conversation:</p>

        <pre><code><span class="line">User: "Who is the CEO of Tesla?"</span>
<span class="line">AI: "Elon Musk is the CEO of Tesla Motors."</span>
<span class="line">User: "What about SpaceX?"</span></code></pre>

        <p>If we naively search our vector database for <code>"What about SpaceX?"</code>, we get <strong>zero relevant results</strong>. Why? Because that query lacks context‚Äîit's a follow-up question that references the previous message.</p>

        <div class="info-box">
          <div class="info-box-title">The Traditional Solution (and Why It Fails)</div>
          <p>Most RAG tutorials suggest "just pass the full conversation history to the LLM." This works for toy demos but breaks in production:</p>
          <ul>
            <li><strong>Token Cost:</strong> Sending 50KB of conversation history costs 10x more than sending 500 bytes</li>
            <li><strong>Latency:</strong> Larger prompts = slower responses (up to 2-3 seconds added delay)</li>
            <li><strong>Context Window Limits:</strong> After 10-15 exchanges, you hit model limits</li>
            <li><strong>Poor Retrieval:</strong> Vector search on "What about him?" returns irrelevant documents</li>
          </ul>
        </div>

        <h3>Our Solution: Contextual Query Rewriting</h3>
        <p>Before searching the vector database, we use Gemini Flash to rewrite the user's query into a <strong>standalone question</strong> that includes all necessary context.</p>

        <p><strong>Here's the actual implementation from <code>src/controllers/agent.controller.ts</code>:</strong></p>

        <pre><code><span class="line">const chat = async (req, res, next) => {</span>
<span class="line">  const { messages } = req.body;</span>
<span class="line">  const lastMessage = messages[messages.length - 1];</span>
<span class="line">  const userId = req.user.id;</span>
<span class="line"></span>
<span class="line">  // Step 1: Refine Search Query (Contextual Query Rewriter)</span>
<span class="line">  let searchQuery = lastMessage.content;</span>
<span class="line"></span>
<span class="line">  if (messages.length > 1) {</span>
<span class="line">    try {</span>
<span class="line">      const { text } = await generateText({</span>
<span class="line">        model: google('gemma-3-12b'),</span>
<span class="line">        messages: messages, // Full conversation history</span>
<span class="line">        system:</span>
<span class="line">          'You are a search query refiner. Rewrite the last user message ' +</span>
<span class="line">          'into a standalone, descriptive search query based on the ' +</span>
<span class="line">          'conversation history. Do NOT answer the question. ' +</span>
<span class="line">          'Return ONLY the rewritten query string.'</span>
<span class="line">      });</span>
<span class="line">      </span>
<span class="line">      searchQuery = text;</span>
<span class="line">      logger.info(`Rewrote query: "${lastMessage.content}" -> "${searchQuery}"`);</span>
<span class="line">    } catch (error) {</span>
<span class="line">      logger.error(`Query rewriting failed: ${error}`);</span>
<span class="line">      // Fallback to original query on error</span>
<span class="line">    }</span>
<span class="line">  }</span>
<span class="line"></span>
<span class="line">  // Step 2: Convert refined query to embedding</span>
<span class="line">  const { embedding } = await embed({</span>
<span class="line">    model: google.textEmbeddingModel('text-embedding-004'),</span>
<span class="line">    value: searchQuery</span>
<span class="line">  });</span>
<span class="line"></span>
<span class="line">  // ... hybrid search with pgvector (covered in next section)</span>
<span class="line">};</span></code></pre>

        <h3>Why We Use Gemma 3 (Not GPT-4)</h3>
        <p>For query rewriting, we use Google's <strong>Gemma 3-12B</strong> model instead of the more powerful Gemini 2.5 Flash. Here's why:</p>

        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin: 2rem 0;">
          <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 1.5rem; border-radius: 12px;">
            <div style="font-size: 2rem; margin-bottom: 0.5rem;">‚ö°</div>
            <div style="font-weight: 700; font-size: 1.125rem; margin-bottom: 0.75rem;">Speed: 200ms vs 800ms</div>
            <div style="font-size: 0.9rem; opacity: 0.95;">Gemma 3 is a lightweight 12B parameter model optimized for simple tasks. It responds 4x faster than Gemini Flash for query rewriting.</div>
          </div>

          <div style="background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%); color: white; padding: 1.5rem; border-radius: 12px;">
            <div style="font-size: 2rem; margin-bottom: 0.5rem;">üí∞</div>
            <div style="font-weight: 700; font-size: 1.125rem; margin-bottom: 0.75rem;">Cost: 100% Free</div>
            <div style="font-size: 0.9rem; opacity: 0.95;">Both Gemma and Gemini Flash are free in Google AI Studio (15 req/min limit). We reserve Gemini Flash for the final answer generation where quality matters more.</div>
          </div>
        </div>

        <h3>Real Example: Query Rewriting in Action</h3>
        <p>Here's what the system logs when rewriting queries:</p>

        <pre><code><span class="line">// Original conversation:</span>
<span class="line">User: "What is TypeScript?"</span>
<span class="line">AI: "TypeScript is a superset of JavaScript..."</span>
<span class="line">User: "What are the benefits?"</span>
<span class="line"></span>
<span class="line">// System Log:</span>
<span class="line">[INFO] Rewrote query: "What are the benefits?" -> "What are the benefits of TypeScript?"</span>
<span class="line"></span>
<span class="line">// Result: Vector search now finds TypeScript documentation, not generic "benefits" articles</span></code></pre>

        <div class="success-box info-box">
          <div class="info-box-title">Performance Impact</div>
          <p>This two-step approach (rewrite ‚Üí search) adds only <strong>200ms of latency</strong> but improves retrieval accuracy by <strong>60-80%</strong> in multi-turn conversations.</p>
          <p>Without query rewriting:</p>
          <ul>
            <li>Follow-up questions return irrelevant documents</li>
            <li>Users have to re-state context every time ("What is TypeScript's type system?")</li>
            <li>Chatbot feels "dumb" and frustrating to use</li>
          </ul>
        </div>

        <p><strong>Next:</strong> Now that we have a standalone query, let's see how we search our vector database with row-level security...</p>
      </section>

      <section id="phase3">
        <span class="step-header">üîç Step 4</span>
        <h2>Phase 3: Hybrid Search with Row-Level Security</h2>
        <p>Now we have a refined standalone query. The next challenge is <strong>multi-tenancy</strong>: How do we let users search the knowledge base while keeping their private documents secure?</p>

        <h3>The Business Requirement</h3>
        <p>In a production RAG system, users need access to two distinct document sets:</p>

        <ul>
          <li><strong>Private Files:</strong> Documents they uploaded (proposals, contracts, internal memos)</li>
          <li><strong>Public Knowledge Base:</strong> Shared company documentation marked as <code>isPublic</code></li>
        </ul>

        <p>Traditional vector databases (Pinecone, Weaviate) require <em>application-level filtering</em>‚Äîyou fetch all results, then filter in JavaScript. This is slow and insecure (one missed filter = data leak).</p>

        <div style="background: #f8fafc; border: 2px dashed #cbd5e1; border-radius: 12px; padding: 2rem; margin: 2rem 0; text-align: center; color: #64748b; font-weight: 600;">
          üîí
          <img src="https://pub-ce2718d3322e486d97486bc7e573557d.r2.dev/rag_tutorial_images/search-scope-venn-diagram.jpg" width="100%" height="auto" />
          <br><br>
          <span style="font-size: 0.875rem; font-weight: 400;">Left Circle: User's Private Files | Right Circle: Public Knowledge Base | Intersection: Accessible Search Results</span>
        </div>

        <h3>Our Solution: Database-Level Security with pgvector</h3>
        <p>PostgreSQL with pgvector lets us enforce access control <strong>in the SQL query itself</strong>. We search both document sets in a single query with blazing-fast performance.</p>

        <h3>Under the Hood: The Actual SQL Query</h3>
        <p>Here's the hybrid search implementation from <code>src/controllers/agent.controller.ts</code>:</p>

        <pre><code><span class="line">// Step 1: Convert refined query to embedding</span>
<span class="line">const { embedding } = await embed({</span>
<span class="line">  model: google.textEmbeddingModel('text-embedding-004'),</span>
<span class="line">  value: searchQuery</span>
<span class="line">});</span>
<span class="line"></span>
<span class="line">const vectorQuery = `[${embedding.join(',')}]`;</span>
<span class="line"></span>
<span class="line">// Step 2: Hybrid Search (User's Private + Public Knowledge Base)</span>
<span class="line">const documents = await prisma.$queryRaw`</span>
<span class="line">  SELECT </span>
<span class="line">    d.content,</span>
<span class="line">    d.metadata,</span>
<span class="line">    f."originalName",</span>
<span class="line">    f."fileKey",</span>
<span class="line">    f."isPublic",</span>
<span class="line">    (d.embedding <=> ${vectorQuery}::vector) as distance</span>
<span class="line">  FROM "Document" d</span>
<span class="line">  LEFT JOIN "File" f ON d."fileId" = f.id</span>
<span class="line">  WHERE (d."userId" = ${userId} OR f."isPublic" = true)</span>
<span class="line">  ORDER BY distance ASC</span>
<span class="line">  LIMIT 5</span>
<span class="line">`;</span></code></pre>

        <div class="info-box">
          <div class="info-box-title">Breaking Down the Query</div>
          <p>Let's understand each part of this powerful SQL query:</p>
          <ul>
            <li><strong><code>(d.embedding &lt;=&gt; ${vectorQuery}::vector)</code>:</strong> Cosine distance calculation between query embedding and document embeddings</li>
            <li><strong><code>WHERE (d."userId" = ${userId} OR f."isPublic" = true)</code>:</strong> Row-level security‚Äîusers only see their files + public ones</li>
            <li><strong><code>ORDER BY distance ASC</code>:</strong> Return most similar documents first (lower distance = higher similarity)</li>
            <li><strong><code>LIMIT 5</code>:</strong> Top 5 results to avoid overwhelming the LLM context window</li>
          </ul>
        </div>

        <h3>Why This Beats Application-Level Filtering</h3>
        <p>Compare the two approaches:</p>

        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin: 2rem 0;">
          <div style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; padding: 1.5rem; border-radius: 12px;">
            <div style="font-size: 2rem; margin-bottom: 0.5rem;">‚ùå</div>
            <div style="font-weight: 700; font-size: 1.125rem; margin-bottom: 0.75rem;">App-Level Filtering</div>
            <div style="font-size: 0.9rem; opacity: 0.95; line-height: 1.6;">
              ‚Ä¢ Fetch ALL documents<br>
              ‚Ä¢ Filter in JavaScript<br>
              ‚Ä¢ Vulnerable to bugs (data leaks)<br>
              ‚Ä¢ Slower (network overhead)<br>
              ‚Ä¢ Pagination is nightmare
            </div>
          </div>

          <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 1.5rem; border-radius: 12px;">
            <div style="font-size: 2rem; margin-bottom: 0.5rem;">‚úì</div>
            <div style="font-weight: 700; font-size: 1.125rem; margin-bottom: 0.75rem;">Database-Level (Our Approach)</div>
            <div style="font-size: 0.9rem; opacity: 0.95; line-height: 1.6;">
              ‚Ä¢ Filter in WHERE clause<br>
              ‚Ä¢ Postgres enforces security<br>
              ‚Ä¢ Impossible to accidentally leak data<br>
              ‚Ä¢ Faster (indexed queries)<br>
              ‚Ä¢ Native pagination support
            </div>
          </div>
        </div>

        <h3>Understanding the <code style="color: #0339a3;">&lt;=&gt;</code> Operator</h3>
        <p>The pgvector extension adds special operators for vector similarity:</p>

        <table style="width: 100%; border-collapse: collapse; margin: 2rem 0; border: 1px solid #e5e7eb;">
          <thead>
            <tr style="background: #f9fafb;">
              <th style="padding: 0.75rem; text-align: left; border: 1px solid #e5e7eb; font-weight: 700;">Operator</th>
              <th style="padding: 0.75rem; text-align: left; border: 1px solid #e5e7eb; font-weight: 700;">Distance Type</th>
              <th style="padding: 0.75rem; text-align: left; border: 1px solid #e5e7eb; font-weight: 700;">Use Case</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="padding: 0.75rem; border: 1px solid #e5e7eb;"><code style="color: #0339a3;">&lt;=&gt;</code></td>
              <td style="padding: 0.75rem; border: 1px solid #e5e7eb;">Cosine distance</td>
              <td style="padding: 0.75rem; border: 1px solid #e5e7eb;">Text similarity (what we use)</td>
            </tr>
            <tr style="background: #f9fafb;">
              <td style="padding: 0.75rem; border: 1px solid #e5e7eb;"><code style="color: #0339a3;">&lt;-&gt;</code></td>
              <td style="padding: 0.75rem; border: 1px solid #e5e7eb;">L2 (Euclidean)</td>
              <td style="padding: 0.75rem; border: 1px solid #e5e7eb;">Spatial/geometric data</td>
            </tr>
            <tr>
              <td style="padding: 0.75rem; border: 1px solid #e5e7eb;"><code style="color: #0339a3;">&lt;#&gt;</code></td>
              <td style="padding: 0.75rem; border: 1px solid #e5e7eb;">Inner product</td>
              <td style="padding: 0.75rem; border: 1px solid #e5e7eb;">Pre-normalized vectors</td>
            </tr>
          </tbody>
        </table>

        <p>Cosine distance measures the <em>angle</em> between two vectors, not their magnitude. This is perfect for text because "cat" and "kitten" should be similar regardless of document length.</p>

        <h3>Performance: Indexing Matters</h3>
        <p>For datasets with >10,000 documents, we create an ivfflat index:</p>

        <pre><code><span class="line">-- Create index for faster similarity search</span>
<span class="line">CREATE INDEX ON "Document" USING ivfflat (embedding vector_cosine_ops)</span>
<span class="line">WITH (lists = 100);</span></code></pre>

        <p>This speeds up queries by <strong>10-100x</strong> compared to sequential scans.</p>

        <h3>Smart Citations: Just-In-Time Access</h3>
        <p>Now that we have the top 5 relevant documents, we need to <strong>cite our sources</strong>. But here's the problem: our files are stored in a private S3 bucket. How do we give the AI (and user) access to these files securely?</p>

        <p><strong>The naive solution (and why it's dangerous):</strong></p>
        <pre><code><span class="line">// ‚ùå BAD: Hardcoded S3 URL (anyone with the URL can access!)</span>
<span class="line">const sourceUrl = `https://my-bucket.s3.amazonaws.com/${fileKey}`;</span></code></pre>

        <p>This exposes your private files to the internet. Anyone who finds the URL in browser DevTools can access confidential documents.</p>

        <h3>Our Solution: Presigned URLs (Temporary Access)</h3>
        <p>Here's how we generate <strong>just-in-time citations</strong> from <code>agent.controller.ts</code>:</p>

        <pre><code><span class="line">// Step 3: Package Context with Smart Citations</span>
<span class="line">const docsMap = documents.map(async (doc) => {</span>
<span class="line">  // Generate Presigned URL for "Source Link"</span>
<span class="line">  let signedUrl = 'unavailable';</span>
<span class="line">  </span>
<span class="line">  if (doc.fileKey) {</span>
<span class="line">    try {</span>
<span class="line">      const command = new GetObjectCommand({</span>
<span class="line">        Bucket: config.aws.s3.bucket,</span>
<span class="line">        Key: doc.fileKey</span>
<span class="line">      });</span>
<span class="line">      </span>
<span class="line">      // URL valid for 1 hour (3600s)</span>
<span class="line">      signedUrl = await getSignedUrl(s3Client, command, { </span>
<span class="line">        expiresIn: 3600 </span>
<span class="line">      });</span>
<span class="line">    } catch (e) {</span>
<span class="line">      logger.error(`Failed to generate signed URL for ${doc.fileKey}`);</span>
<span class="line">    }</span>
<span class="line">  }</span>
<span class="line"></span>
<span class="line">  const visibilityLabel = doc.isPublic ? '[Public Doc]' : '[Your Private Doc]';</span>
<span class="line">  return `Source: ${doc.originalName} ${visibilityLabel}\nLink: ${signedUrl}\nContent: ${doc.content}`;</span>
<span class="line">});</span>
<span class="line"></span>
<span class="line">const contextArray = await Promise.all(docsMap);</span>
<span class="line">const context = contextArray.join('\n\n');</span></code></pre>

        <div class="success-box info-box">
          <div class="info-box-title">Why Presigned URLs are Critical for Security</div>
          <p>This approach gives us three key security guarantees:</p>
          <ul>
            <li><strong>Time-Limited Access:</strong> URLs expire after 1 hour‚Äîno permanent file access</li>
            <li><strong>No Bucket Exposure:</strong> S3 bucket remains fully private (no public ACLs)</li>
            <li><strong>Audit Trail:</strong> Every file access is logged via S3 access logs</li>
            <li><strong>Fine-Grained Control:</strong> Different users get different URLs for the same file</li>
          </ul>
          <p>Even if someone intercepts the URL, it only works for 1 hour and only for that specific file.</p>
        </div>

        <h3>The Final Context Passed to Gemini</h3>
        <p>After generating presigned URLs for all 5 source documents, we package everything into a single context string:</p>

        <pre><code><span class="line">// System prompt with context and citations</span>
<span class="line">const systemPrompt = `You are a helpful AI assistant. </span>
<span class="line">Answer the user's question based ONLY on the following context.</span>
<span class="line"></span>
<span class="line">The context includes source links. If the answer is found in a file, </span>
<span class="line">strictly cite the source using the provided Link format: [Source Name](Link).</span>
<span class="line">If the answer is not in the context, say "I don't know".</span>
<span class="line"></span>
<span class="line">Context:</span>
<span class="line">${context}`;</span>
<span class="line"></span>
<span class="line">// Generate Response (Stream)</span>
<span class="line">const result = streamText({</span>
<span class="line">  model: google('gemini-2.5-flash-lite'),</span>
<span class="line">  messages,</span>
<span class="line">  system: systemPrompt</span>
<span class="line">});</span>
<span class="line"></span>
<span class="line">result.pipeTextStreamToResponse(res);</span></code></pre>

        <p>The AI now has access to the top 5 most relevant document chunks <em>with clickable, temporary source links</em>. Users can verify claims by clicking through to the original documents‚Äîbut only for 1 hour.</p>

        <div class="info-box">
          <div class="info-box-title">Real-World Example Response</div>
          <p>When a user asks <strong>"What is our refund policy?"</strong>, the AI might respond:</p>
          <blockquote style="border-left: 4px solid #667eea; padding-left: 1rem; margin: 1rem 0; font-style: italic; color: #4a5568;">
            "According to our company handbook, we offer a 30-day money-back guarantee for all products. You can initiate a refund by contacting support@company.com. <br><br>
            Source: <span style="color: #667eea; text-decoration: underline;" >Company Handbook - Section 5.2</span>[Public Doc]"
          </blockquote>
          <p>Clicking the link downloads the PDF with a presigned URL that expires in 1 hour. Perfect balance of convenience and security!</p>
        </div>

        <p><strong>Next:</strong> Let's explore the final phase‚Äîmultimodal intelligence with Gemini Vision...</p>
      </section>

      <section id="phase4">
        <span class="step-header">üëÅÔ∏è Step 5</span>
        <h2>Phase 4: Visual RAG - Multimodal Intelligence</h2>
        <p>This is where we go beyond traditional RAG systems that only understand text. When users upload images, we don't just store them‚Äîwe <strong>understand them</strong> using Gemini Vision.</p>

        <h3>The Problem with Traditional OCR</h3>
        <p>Most "image search" solutions use Optical Character Recognition (OCR) to extract text from images. This has critical limitations:</p>

        <ul>
          <li><strong>Text-Only:</strong> OCR only extracts visible text, missing charts, diagrams, and visual context</li>
          <li><strong>Quality-Dependent:</strong> Fails with handwriting, low resolution, or poor lighting</li>
          <li><strong>No Understanding:</strong> A photo of a receipt shows "$49.99" but OCR doesn't know it's a refund</li>
          <li><strong>Layout Issues:</strong> Tables and multi-column text confuse OCR engines</li>
        </ul>

        <h3>Our Solution: Gemini Vision for Image Understanding</h3>
        <p>Instead of extracting text, we send the entire image to Gemini Vision and ask it to <em>describe what it sees</em>. The AI-generated description is then converted to a vector and stored alongside text documents.</p>

        <div style="background: #f8fafc; border: 2px dashed #cbd5e1; border-radius: 12px; padding: 2rem; margin: 2rem 0; text-align: center; color: #64748b; font-weight: 600;">
          üñºÔ∏è 
          <img src="https://pub-ce2718d3322e486d97486bc7e573557d.r2.dev/rag_tutorial_images/visual-rag-pipeline-diagram.jpg" width="100%" height="auto" />
          <br><br>
          <span style="font-size: 0.875rem; font-weight: 400;">Receipt Image ‚Üí Gemini Vision (AI Description) ‚Üí Text Embedding ‚Üí Vector DB ‚Üí Searchable!</span>
        </div>

        <h3>Implementation: Image Processing in the Ingestion Worker</h3>
        <p>Here's the actual code from <code>src/jobs/ingestion.worker.ts</code> that handles image uploads:</p>

        <pre><code><span class="line">// Step 3: Content Extraction based on MIME type</span>
<span class="line">let extractedText = '';</span>
<span class="line"></span>
<span class="line">if (mimeType.startsWith('image/')) {</span>
<span class="line">  // Use Gemini Vision to describe the image</span>
<span class="line">  logger.info(`Processing image with Gemini Vision: ${fileId}`);</span>
<span class="line">  </span>
<span class="line">  const { text } = await generateText({</span>
<span class="line">    model: google('gemini-2.5-flash-lite'),</span>
<span class="line">    messages: [</span>
<span class="line">      {</span>
<span class="line">        role: 'user',</span>
<span class="line">        content: [</span>
<span class="line">          {</span>
<span class="line">            type: 'text',</span>
<span class="line">            text: 'Describe this image in detail for search indexing. ' +</span>
<span class="line">                  'Include all visible text, objects, people, and context.'</span>
<span class="line">          },</span>
<span class="line">          {</span>
<span class="line">            type: 'image',</span>
<span class="line">            image: buffer // Raw image binary</span>
<span class="line">          }</span>
<span class="line">        ]</span>
<span class="line">      }</span>
<span class="line">    ]</span>
<span class="line">  });</span>
<span class="line"></span>
<span class="line">  extractedText = text;</span>
<span class="line">  logger.info(`Gemini Vision response: ${text.substring(0, 100)}...`);</span>
<span class="line">}</span></code></pre>

        <div class="info-box">
          <div class="info-box-title">Why "Describe this image in detail for search indexing"?</div>
          <p>The prompt engineering is critical here. We're asking Gemini to:</p>
          <ul>
            <li><strong>Be Comprehensive:</strong> "in detail" ensures we don't miss important context</li>
            <li><strong>Extract Text:</strong> "all visible text" makes it act like OCR + understanding</li>
            <li><strong>Add Context:</strong> "objects, people, and context" adds semantic meaning</li>
            <li><strong>Optimize for Search:</strong> "for search indexing" biases toward searchable keywords</li>
          </ul>
        </div>

        <h3>Real-World Example: Receipt Processing</h3>
        <p>Let's see what happens when a user uploads a receipt image:</p>

        <table style="width: 100%; border-collapse: collapse; margin: 2rem 0; border: 1px solid #e5e7eb;">
          <thead>
            <tr style="background: #f9fafb;">
              <th style="padding: 0.75rem; text-align: left; border: 1px solid #e5e7eb; font-weight: 700;">Input</th>
              <th style="padding: 0.75rem; text-align: left; border: 1px solid #e5e7eb; font-weight: 700;">Gemini Vision Output</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="padding: 0.75rem; border: 1px solid #e5e7eb; vertical-align: top;">
                <strong>Image:</strong> Photo of coffee shop receipt
              </td>
              <td style="padding: 0.75rem; border: 1px solid #e5e7eb;">
                "This is a receipt from Starbucks dated January 15, 2025. The receipt shows a purchase of a Grande Latte ($5.45) and a Blueberry Scone ($3.95). The total amount is $9.40 paid with a Visa card ending in 1234. The store location is 123 Main St, Seattle WA. Receipt number: 4567-8901."
              </td>
            </tr>
          </tbody>
        </table>

        <p><strong>What just happened?</strong> Gemini Vision didn't just perform OCR‚Äîit:</p>
        <ul>
          <li>Identified the business (Starbucks)</li>
          <li>Extracted individual line items with prices</li>
          <li>Recognized payment method details</li>
          <li>Captured the store location</li>
          <li>Structured everything in searchable natural language</li>
        </ul>

        <p>Now when the user asks <strong>"How much did I spend at Starbucks last month?"</strong>, our vector search finds this receipt based on semantic similarity!</p>

        <h3>From Image Description to Vector Storage</h3>
        <p>After Gemini Vision generates the description, the worker treats it like any other text document:</p>

        <pre><code><span class="line">// Step 4: Chunking (same for text and image descriptions)</span>
<span class="line">const splitter = new RecursiveCharacterTextSplitter({</span>
<span class="line">  chunkSize: 1000,</span>
<span class="line">  chunkOverlap: 200</span>
<span class="line">});</span>
<span class="line"></span>
<span class="line">const chunks = await splitter.createDocuments([extractedText]);</span>
<span class="line"></span>
<span class="line">// Step 5: Generate embeddings for each chunk</span>
<span class="line">for (const chunk of chunks) {</span>
<span class="line">  const { embedding } = await embed({</span>
<span class="line">    model: google.textEmbeddingModel('text-embedding-004'),</span>
<span class="line">    value: chunk.pageContent</span>
<span class="line">  });</span>
<span class="line"></span>
<span class="line">  // Step 6: Store in PostgreSQL (pgvector)</span>
<span class="line">  await prisma.$executeRaw`</span>
<span class="line">    INSERT INTO "Document" (content, embedding, userId, fileId)</span>
<span class="line">    VALUES (${chunk.pageContent}, ${embedding}::vector, ${userId}, ${fileId})</span>
<span class="line">  `;</span>
<span class="line">}</span></code></pre>

        <div class="success-box info-box">
          <div class="info-box-title">The Magic: Unified Search Across Text and Images</div>
          <p>Because image descriptions are stored as vectors just like text documents, <strong>users can search everything in one query</strong>:</p>
          <ul>
            <li>Query: <strong>"Show me proof of the laptop purchase"</strong></li>
            <li>Results: PDF invoice + photo of receipt + email confirmation</li>
          </ul>
          <p>The system doesn't care whether the source was a PDF, text file, or image‚Äîit's all searchable semantic knowledge.</p>
        </div>

        <h3>Cost Analysis: Is Gemini Vision Free?</h3>
        <p>Gemini Vision falls under the same free tier as text models:</p>

        <ul>
          <li><strong>Free Tier:</strong> 15 requests/minute, 1,500 requests/day</li>
          <li><strong>Average Processing Time:</strong> ~2 seconds per image</li>
          <li><strong>Daily Capacity:</strong> ~1,500 images processed for free</li>
        </ul>

        <p>For a startup or side project, this is more than enough. Even with 100 active users uploading 5 images/day, you're well within the free tier.</p>

        <p><strong>Congratulations!</strong> You now understand all 4 phases of a production-grade RAG system. Let's wrap up...</p>
      </section>

      <section id="conclusion">
        <span class="step-header">üéØ Conclusion</span>
        <h2>Build vs Buy: Why This Architecture Matters</h2>
        <p>Commercial RAG solutions like Pinecone ($70/mo), Weaviate ($50/mo), or hosted vector databases charge premium prices for functionality you just learned to build for <strong>$0/month</strong>.</p>

        <h3>What You Actually Built (and Most Tutorials Skip)</h3>
        <p>This isn't a "hello world" RAG tutorial. You implemented production-grade patterns that most companies pay senior engineers $150k+ to build:</p>

        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1.5rem; margin: 2rem 0;">
          <div style="background: white; border: 2px solid #e5e7eb; padding: 1.5rem; border-radius: 12px;">
            <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">üîê</div>
            <div style="font-weight: 700; margin-bottom: 0.5rem; color: #1a202c;">Multi-Tenant Security</div>
            <div style="font-size: 0.9rem; color: #4a5568; line-height: 1.6;">Row-level security in PostgreSQL. Users can't access each other's documents‚Äîenforced at the database layer, not application code.</div>
          </div>

          <div style="background: white; border: 2px solid #e5e7eb; padding: 1.5rem; border-radius: 12px;">
            <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">‚ö°</div>
            <div style="font-weight: 700; margin-bottom: 0.5rem; color: #1a202c;">Async Job Processing</div>
            <div style="font-size: 0.9rem; color: #4a5568; line-height: 1.6;">BullMQ workers prevent blocking operations. Process 50MB PDFs without slowing down your API responses.</div>
          </div>

          <div style="background: white; border: 2px solid #e5e7eb; padding: 1.5rem; border-radius: 12px;">
            <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">üéØ</div>
            <div style="font-weight: 700; margin-bottom: 0.5rem; color: #1a202c;">Contextual Query Rewriting</div>
            <div style="font-size: 0.9rem; color: #4a5568; line-height: 1.6;">Solve the follow-up question problem. "What about him?" becomes "Who is the CEO of SpaceX?" automatically.</div>
          </div>

          <div style="background: white; border: 2px solid #e5e7eb; padding: 1.5rem; border-radius: 12px;">
            <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">‚òÅÔ∏è</div>
            <div style="font-weight: 700; margin-bottom: 0.5rem; color: #1a202c;">Zero-Server Uploads</div>
            <div style="font-size: 0.9rem; color: #4a5568; line-height: 1.6;">Presigned URLs for direct browser-to-R2 uploads. Handle 1000 concurrent uploads without OOM crashes.</div>
          </div>

          <div style="background: white; border: 2px solid #e5e7eb; padding: 1.5rem; border-radius: 12px;">
            <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">üîó</div>
            <div style="font-weight: 700; margin-bottom: 0.5rem; color: #1a202c;">Smart Citations</div>
            <div style="font-size: 0.9rem; color: #4a5568; line-height: 1.6;">Just-in-time presigned URLs for source documents. Temporary access (1 hour) keeps S3 buckets fully private.</div>
          </div>

          <div style="background: white; border: 2px solid #e5e7eb; padding: 1.5rem; border-radius: 12px;">
            <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">üëÅÔ∏è</div>
            <div style="font-weight: 700; margin-bottom: 0.5rem; color: #1a202c;">Multimodal RAG</div>
            <div style="font-size: 0.9rem; color: #4a5568; line-height: 1.6;">Gemini Vision understands images. Search across PDFs, text files, and photos in a single query.</div>
          </div>
        </div>

        <h3>The Resume Hack: Prove Senior-Level Skills</h3>
        <p>If you're a student or job seeker, adding this project to your portfolio signals to hiring managers that you understand:</p>

        <ul>
          <li><strong>Distributed Systems:</strong> Async workers, job queues, background processing</li>
          <li><strong>Database Design:</strong> Vector databases, indexing strategies, query optimization</li>
          <li><strong>Security Engineering:</strong> Multi-tenancy, presigned URLs, row-level security</li>
          <li><strong>AI/ML Integration:</strong> Embeddings, semantic search, prompt engineering</li>
          <li><strong>Cloud Architecture:</strong> S3-compatible storage, cost optimization (zero egress)</li>
        </ul>

        <p>This is the difference between "I built a chatbot" and "I architected a production-grade RAG system with multi-tenant security and multimodal intelligence."</p>

        <div class="info-box">
          <div class="info-box-title">Cost Comparison: Build vs Buy</div>
          <p>Let's compare our $0/month solution to commercial alternatives:</p>
          <table style="width: 100%; border-collapse: collapse; margin: 1rem 0; border: 1px solid #e5e7eb;">
            <thead>
              <tr style="background: #f9fafb;">
                <th style="padding: 0.75rem; text-align: left; border: 1px solid #e5e7eb;">Solution</th>
                <th style="padding: 0.75rem; text-align: left; border: 1px solid #e5e7eb;">Monthly Cost</th>
                <th style="padding: 0.75rem; text-align: left; border: 1px solid #e5e7eb;">Annual Cost</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td style="padding: 0.75rem; border: 1px solid #e5e7eb;"><strong>Our Stack (Free Tier)</strong></td>
                <td style="padding: 0.75rem; border: 1px solid #e5e7eb; color: #10b981; font-weight: 700;">$0</td>
                <td style="padding: 0.75rem; border: 1px solid #e5e7eb; color: #10b981; font-weight: 700;">$0</td>
              </tr>
              <tr style="background: #f9fafb;">
                <td style="padding: 0.75rem; border: 1px solid #e5e7eb;">Pinecone (Vector DB)</td>
                <td style="padding: 0.75rem; border: 1px solid #e5e7eb;">$70</td>
                <td style="padding: 0.75rem; border: 1px solid #e5e7eb;">$840</td>
              </tr>
              <tr>
                <td style="padding: 0.75rem; border: 1px solid #e5e7eb;">AWS S3 (5GB + egress)</td>
                <td style="padding: 0.75rem; border: 1px solid #e5e7eb;">$45</td>
                <td style="padding: 0.75rem; border: 1px solid #e5e7eb;">$540</td>
              </tr>
              <tr style="background: #f9fafb;">
                <td style="padding: 0.75rem; border: 1px solid #e5e7eb;">OpenAI API (moderate usage)</td>
                <td style="padding: 0.75rem; border: 1px solid #e5e7eb;">$50</td>
                <td style="padding: 0.75rem; border: 1px solid #e5e7eb;">$600</td>
              </tr>
              <tr style="font-weight: 700;">
                <td style="padding: 0.75rem; border: 1px solid #e5e7eb;"><strong>Commercial Total</strong></td>
                <td style="padding: 0.75rem; border: 1px solid #e5e7eb; color: #ef4444;">$165/mo</td>
                <td style="padding: 0.75rem; border: 1px solid #e5e7eb; color: #ef4444;">$1,980/year</td>
              </tr>
            </tbody>
          </table>
          <p style="margin-top: 1rem;"><strong>Your Savings:</strong> $1,980/year by building instead of buying. That's a MacBook Pro or 6 months of rent.</p>
        </div>

        <h3>Next Steps: From Tutorial to Production</h3>
        <p>Ready to deploy this as a real product? Here's your checklist:</p>

        <ol>
          <li><strong>Environment Setup:</strong> Get API keys for Google AI Studio (free) and Cloudflare R2</li>
          <li><strong>Database:</strong> Deploy PostgreSQL with pgvector on Render.com or Railway.app (both have free tiers)</li>
          <li><strong>Redis:</strong> Use Upstash free tier for BullMQ job queue</li>
          <li><strong>Deploy API:</strong> Render.com or Railway.app (both have free tiers)</li>
          <li><strong>Testing:</strong> Upload a PDF and image, test the chat interface</li>
          <li><strong>Scale:</strong> Monitor usage and upgrade to paid tiers only when you hit limits</li>
        </ol>

        <p><strong>Congratulations!</strong> You now have the knowledge to build production-grade AI applications. Keep learning, keep building! üöÄ</p>
      </section>

      <!-- Early Access Offer Section -->
      <section style="margin: 4rem 0; padding: 3rem; background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%); border-radius: 16px; box-shadow: 0 10px 40px rgba(251, 191, 36, 0.3); border: 3px solid #fbbf24;">
        <div style="text-align: center; color: #1a202c;">
          <div style="font-size: 2.5rem; margin-bottom: 0.5rem;">üöÄ</div>
          <h2 style="font-size: 2.25rem; font-weight: 800; margin-bottom: 1rem; color: #1a202c;">Early Access Launch Special</h2>
          <p style="font-size: 1.25rem; margin-bottom: 2rem; color: #3a3a3a; font-weight: 500;">Get the Production-Ready Node.js Enterprise Template</p>

          <div style="background: rgba(255,255,255,0.95); padding: 2rem; border-radius: 12px; margin: 2rem auto; max-width: 600px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <div style="margin-bottom: 1.5rem;">
              <div style="font-size: 1rem; color: #6b7280; text-decoration: line-through; margin-bottom: 0.25rem;">Regular Price: $20</div>
              <div style="font-size: 3rem; font-weight: 800; color: #10b981; line-height: 1;">$4</div>
              <div style="display: inline-block; background: #dc2626; color: white; padding: 0.35rem 0.75rem; border-radius: 50px; font-size: 0.875rem; font-weight: 700; margin-top: 0.5rem;">80% OFF - Limited Time</div>
            </div>

            <div style="text-align: left; margin: 1.5rem 0; padding: 1.5rem; background: #f9fafb; border-radius: 8px;">
              <div style="font-weight: 700; margin-bottom: 1rem; color: #1a202c; font-size: 1.125rem;">‚úÖ What's Included:</div>
              <ul style="list-style: none; padding: 0; margin: 0; color: #4a5568; line-height: 2;">
                <li>‚úì Complete RAG Pipeline (Production-ready AI integration with embeddings)</li>
                <li>‚úì Authentication & RBAC (Secure JWT, Refresh Tokens, Admin/User roles)</li>
                <li>‚úì Cloudflare R2 / S3 Integration (File uploads with zero egress fees)</li>
                <li>‚úì Socket.IO Real-Time Notifications</li>
                <li>‚úì Background Processing (BullMQ Workers for heavy tasks & ingestion)</li>
                <li>‚úì pgvector Setup & Migrations</li>
                <li>‚úì Automated Maintenance (Cron jobs for file cleanup & token management)</li>
                <li>‚úì Full API Documentation (Swagger)</li>
                <li>‚úì Developer Experience (TypeScript, Jest Tests, ESLint, & Prettier)</li>
                <li>‚úì Docker Compose & Railway.toml for instant cloud deployment (No cost)</li>
                <li>‚úì Production-ready deployment (Render.com or Railway.app)</li>
              </ul>
            </div>

            <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 1.5rem; border-radius: 8px; margin: 1.5rem 0; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);">
              <div style="font-weight: 700; font-size: 1.125rem; margin-bottom: 0.5rem;">
                üéÅ LIFETIME ACCESS: Get every future upgrade for FREE
              </div>
              <div style="font-size: 0.95rem; opacity: 0.95; line-height: 1.5; margin-bottom: 0.75rem;">
                You secure immediate access to all upcoming tools & features (including the <strong>Stripe Integration</strong> & <strong>React Admin Dashboard</strong>) without paying a cent more.
              </div>
              <div style="background: rgba(255, 255, 255, 0.2); padding: 0.5rem 0.75rem; border-radius: 6px; font-size: 0.875rem; font-weight: 600; display: inline-block;">
                ‚ö†Ô∏è Price increases as new features are added. Lock in this rate today.
              </div>
            </div>

            <a href="https://aymenkani.gumroad.com/l/nodejs-enterprise-launchpad/UDEMY-VIP?price=4&option=2nCmfCVPlr707OzzOD7UGA%3D%3D&_gl=1*2ay5ia*_ga*NTYyNDU1Mjc4LjE3NjA5NzUzNDg.*_ga_6LJN6D94N6*czE3NjU5ODAzOTUkbzE3NCRnMSR0MTc2NTk4MDU1OCRqNjAkbDAkaDA." target="_blank" style="display: block; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 1.25rem 2rem; border-radius: 12px; text-decoration: none; font-weight: 700; font-size: 1.25rem; margin-top: 1.5rem; box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4); transition: transform 0.2s, box-shadow 0.2s;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 25px rgba(102, 126, 234, 0.5)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 6px 20px rgba(102, 126, 234, 0.4)';">
              Download Source Code ‚Üí
            </a>

            <div style="margin-top: 1.5rem; font-size: 0.875rem; color: #6b7280;">
              üí≥ Secure checkout<br>
              One-time payment, lifetime access
            </div>
          </div>

          <div style="margin-top: 2rem; opacity: 0.9; font-size: 0.95rem; color: #3a3a3a;">
            <strong>Why pay $4 instead of building from scratch?</strong><br>
            Save 40+ hours of setup, debugging, and deployment. Get production-tested code that just works.
          </div>
        </div>
      </section>
    </main>

    <!-- Progress Sidebar -->
    <aside class="progress-sidebar">
      <div class="progress-title">Your Progress</div>
      <ul class="progress-list">
        <li class="active"><a href="#intro">Introduction</a></li>
        <li><a href="#architecture">The Architecture</a></li>
        <li><a href="#phase1">Zero-Cost Storage</a></li>
        <li><a href="#phase2">The Brain</a></li>
        <li><a href="#phase3">Hybrid Search</a></li>
        <li><a href="#phase4">Visual RAG</a></li>
        <li><a href="#conclusion">Build vs Buy</a></li>
      </ul>
      <div class="sidebar-promo">
        <div class="promo-icon">üöÄ</div>
        <h3>Invest in your Future</h3>
        <p>
          Get a <strong>production-ready architecture</strong> with <strong style="font-size: 1rem; color:#0215aa">Free</strong> lifetime access to new updates and features.
        </p>
        
        <a href="https://aymenkani.gumroad.com/l/nodejs-enterprise-launchpad/UDEMY-VIP?price=13&option=2nCmfCVPlr707OzzOD7UGA%3D%3D&_gl=1*2ay5ia*_ga*NTYyNDU1Mjc4LjE3NjA5NzUzNDg.*_ga_6LJN6D94N6*czE3NjU5ODAzOTUkbzE3NCRnMSR0MTc2NTk4MDU1OCRqNjAkbDAkaDA." target="_blank" class="promo-btn">
          Get Template <span class="price-tag" style="font-size: 1rem; color: #ffffff; text-decoration: line-through; margin-bottom: 0.25rem;">$20 </span><span class="price-tag" style="font-size: 1.1rem;">$4</span>
          <div class="btn-subtext">Early Adopter Launch (80% OFF)</div>
        </a>
      </div>
    </aside>
  </div>
   <!-- Sticky Subscription Bar -->
    <div class="sticky-sub-bar is-hidden" id="stickySubBar">
        <div class="sticky-content">
            
            <!-- Text Section -->
            <div class="sticky-text-group">
                <h3 class="sticky-headline">
                    <span style="font-size: 1.25rem;">üéÅ</span> 
                    Join the Community
                </h3>
                <p class="sticky-subtext">Get free tutorials, AI news & special discounts directly to your inbox.</p>
            </div>
            
            <!-- Form Section -->
            <form action="https://gumroad.com/follow_from_embed_form" method="post" id="gumroad-follow-form-embed" class="sticky-form">
                <input type="hidden" name="seller_id" value="8461277886488"/>
                <input id="gumroad-follow-form-embed-input" class="sticky-input" type="email" placeholder="you@example.com" name="email" required>
                <button type="submit" id="gumroad-follow-form-embed-button" class="sticky-btn">
                  Subscribe
                </button>
            </form>
            
            <!-- Close Button -->
            <button onclick="document.getElementById('stickySubBar').classList.add('is-hidden')" class="sticky-close-btn" aria-label="Close">
                <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>
    <live-demo-btn></live-demo-btn>

    <script src="live-demo-component.js" defer></script>
    <script src="../js/udemy-widget.js" defer></script>

  <script>
    // Active section tracking on scroll
    const sections = document.querySelectorAll('section[id]');
    const progressItems = document.querySelectorAll('.progress-list li');

    window.addEventListener('scroll', () => {
      let current = '';
      
      sections.forEach((section, index) => {
        const sectionTop = section.offsetTop;
        const sectionHeight = section.clientHeight;
        if (window.scrollY >= (sectionTop - 150)) {
          current = section.getAttribute('id');
        }
      });

      progressItems.forEach((item, index) => {
        item.classList.remove('active');
        const link = item.querySelector('a');
        if (link.getAttribute('href') === `#${current}`) {
          item.classList.add('active');
        }
      });
    });
  </script>

    <script>
       // Simulate waiting for scroll or time delay to show the bar
        setTimeout(() => {
            document.getElementById('stickySubBar').classList.remove('is-hidden');
        }, 1000);
    </script>
</body>
</html>
